@page "/portfolio-instance-list/{SPName}"
@using Syncfusion.Blazor.Navigations
@using System.Collections.ObjectModel
@using System.ComponentModel.Design
@using Common.Models
@layout DashboardLayout
@attribute [Authorize]
@using Microsoft.AspNetCore.SignalR.Client
@inject PortfolioHttpClient PortfolioHttpClient
@inject ILogger<PortfolioInstanceList2> Logger
@using System.Text.Json
@using Common.Messages
@using Syncfusion.Blazor
@inject NavigationManager NavigationManager
@inject HubConnection HubConnection
@inject PageHistoryState PageHistory

<SfDashboardLayout Columns="10" CellSpacing="@(new double[] { 10, 10 })" MediaQuery="max-width:700px">

    <DashboardLayoutPanels >

        <DashboardLayoutPanel Column="0" Row="0" SizeX="10" SizeY="1">

            <ContentTemplate>
                <div class="card-body text-white bg-black mb-3">
 
                    <table class="table table-dark table-bordered table-hover">
                        <thead><tr class="headerRow"><th style="text-align: left; font-size: 30px;">Liquidation Strategy Instances</th></tr></thead>
                        <thead><tr class="headerRow"><th style="text-align: left; font-size: 20px;">Fund : Gibraltar Fund: Hamilton Opportunity Fund PCC </th></tr></thead>
                        <thead><tr class="headerRow"><th style="text-align: left; font-size: 20px;">SP : Hamilton VECHAIN Treasury Cell</th></tr></thead>
                    </table>
                </div>
            </ContentTemplate>
        </DashboardLayoutPanel>


        <DashboardLayoutPanel Column="0" Row="3" SizeX="10" SizeY="2">

            <ContentTemplate>
                
                <div class="table-responsive">
                    <table class="table table-dark table-bordered table-striped table-hover">
                        <thead bgcolor="black"><tr class="configHeaderRow" >
                            <th>Strategy Instance</th>
                            <th>Strategy</th>
                            <th>Exchanges</th>
                            <th>Subscription Price</th>
                            <th>Maximum Order Size</th>
                            <th>Days Left</th>
                            <th>Order Batch Size</th>
                            <th>Coin Pair</th>
                            <th>Total Coin To Liquidate</th>
                            <th>Daily Target</th>
                            <th>Total Liquidated</th>
                            <th>Liquidated Today</th>
                            <th>Total Fills</th>
                            <th>Today's Fills</th>
                            <th>Strategy State</th>
                            <th>Strategy Mode</th>
                            <th>Strategy Control</th>
                            <th>Dashboard</th>
                            <th>Config</th>
                            <th>Mkt Order</th>
                        </tr></thead>

                        @foreach (var config in _configs)
                        {
                            <tr class="expense-container">
                                <td>@config.StrategySPSubscriptionConfig.ConfigName</td>
                                <td>@config.Strategy.StrategyName</td>
                                <td>@config.Exchanges</td>
                                <td>@config.SubscriptionPrice</td>
                                <td>@config.OrderSize</td>
                                <td>@config.NumDaysRemaining</td>
                                <td>@config.BatchSize</td>
                                <td>@config.CoinPair.Name</td>
                                <td>@config.CoinAmount</td>
                                <td>@config.DailyLiquidationTarget</td>
                                <td>@config.TotalCoinLiquidated</td>
                                <td>@config.TotalCoinLiquidatedToday</td>
                                <td>@config.TotalFills</td>
                                <td>@config.DailyFills</td>
                                @if (config.StrategyState)
                                {
                                    <td style="background: green; opacity: 0.8;">@config.StrategyStateStr</td>
                                }

                                else
                                {
                                    <td style="background: red; opacity: 0.8;">@config.StrategyStateStr</td>
                                }
                                
                                <td>@config.MakerMode.ToString()</td>
                                @if (config.StrategyState)
                                {
                                    <td><button class="btn btn-primary" style="background: green;" @onclick="@(() => StrategyOnOffEvent(config))">On/Off</button></td>
                                }
                                else
                                {
                                    <td><button class="btn btn-primary" style="background: red;" @onclick="@(() => StrategyOnOffEvent(config))">On/Off</button></td>
                                }
                                
                                <td><button class="btn btn-warning" style="background: #927b00; color: white;" @onclick="@(() => GoToDashBoard(config))">Dashboard</button></td>
                                <td><button class="btn btn-warning" style="background: #927b00; color: white;" @onclick="@(() => EditConfig(config))">Edit Config</button></td>
                                <td><button class="btn btn-warning" style="background: #927b00; color: white;" @onclick="@(() => PlaceMarketOrder(config))">Mkt Order</button></td>
                            </tr>
                        }
                    </table>
                </div>
                
                

                
            </ContentTemplate>
        </DashboardLayoutPanel>



    </DashboardLayoutPanels>
</SfDashboardLayout>


@code
{
    [Parameter]
    public string? SPName { get; set; }

    public string color { get; set; } = "green";
    public string fontcolor { get; set; } = "black";
    private bool _displayDashboard = false;
    SfGrid<LiquidationConfigurationDTO>? Grid { get; set; }
    SfGrid<FairValueDisplay>? Grid2 { get; set; }
    SfGrid<ConnectorStatus>? ConnectorStatusGrid { get; set; }
    SfGrid<OwnOrderChange> OpenOrdersGrid { get; set; }
    SfGrid<TradeMsg> TradesGrid { get; set; }
    SfGrid<DifferentBalances> ExchangeBalancesGrid { get; set; }
    SfGrid<DifferentFills> ExchangeFillsGrid { get; set; }
    SfGrid<LivePriceGrid> _GridLivePrice { get; set; }
    SfButton AddNewButton;
    SfButton DashBoardButton;
    SfButton SwitchMakerTakerButton;
    SfChart Chart;
    private List<int> _badRowList = new();
    private List<int> _goodRowList = new();

    private List<LiquidationConfigurationDTO> _configs = new ();
    private Dictionary<int, LiquidationConfigurationDTO> _configTableForLive = new();
    private Dictionary<string, int> _instanceToIdTable = new();
    private Dictionary<int, Dictionary<string, DifferentBalances>> _exchangeBalancesTable = new();
    private Dictionary<int, List<DifferentBalances>> _masterExchangeBalancesList = new();
    private List<DifferentBalances> _chosenBalanceList { get; set; } = new();

    private Dictionary<int, Dictionary<string, DifferentFills>> _exchangeFillsTable = new();
    private Dictionary<int, List<DifferentFills>> _masterExchangeFillsList = new();
    private List<DifferentFills> _chosenFillsList { get; set; } = new();

    private Dictionary<string, Dictionary<string, OwnOrderChange>> _masterOrderTable { get; set; } = new ();
    
    private Dictionary<string, Dictionary<string, TradeMsg>> _masterTradeTable { get; set; } = new ();
    private Dictionary<string, List<TradeMsg>> _tradeLists { get; set; } = new ();
    private Dictionary<int, VenueDTO> _venues = new Dictionary<int, VenueDTO>();

    private Dictionary<string, ConnectorStatus> _exchangeStatus = new ();

    private Dictionary<string, bool> _strategyInstanceEnabled = new();

    private static string ConnectorUp = "UP";
    private static string ConnectorDown = "DOWN";
    private static string StrategyUp = "e-success";
    private static string StrategyDown = "e-danger";
    private CancellationTokenSource _cts;
    //private List<ExchangeDetailsDTO> _exchangeDetails = new();
    private string _spName { get; set; }

    private Dictionary<string, Dictionary<string, LivePriceGrid>> _livePriceTable { get; set; } = new();
    private List<LivePriceGrid> _livePriceGrid { get; set; } = new();
    private Dictionary<string, Dictionary<string, LivePriceGrid>> _previousLivePriceTable { get; set; } = new(); 
    private int _livePriceIndexCounter { get; set; } = 0;

    private string _fairValueLiquidationButtonStatus = "badge badge-danger";
    private decimal _previousPrice = 0;

    private string _strategyStatus = StrategyDown;
    private Dictionary<string, string> _strategyColorStatus = new();
    bool? strategyOnOffStatus = null;
    List<ConnectorStatus> _connectorStatus = new();
    

    private List<OwnOrderChange> _openOrderList { get; set; } = new List<OwnOrderChange>();
    private List<TradeMsg> _tradeList { get; set; } = new List<TradeMsg>();
    private Dictionary<int, Dictionary<string, OpeningExchangeBalanceDTO>> _openingExchangeBalances = new();
    private string _chosenInstance = "";
    //private List<FairValueChartData> _fairValueChartData { get; set; } = new();
    public ObservableCollection<FairValueChartData> _BinanceValueChartData { get; set; } = new();
    public ObservableCollection<FairValueChartData> _BitfinexValueChartData { get; set; } = new();
    private int dataLength = 50;
    private PeriodicTimer _chartTimer;
    private decimal _lastBinanceFairValue { get; set; }
    private decimal _lastBitfinexFairValue { get; set; }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            PageHistory.AddPageToHistory($"portfolio-instance-list/{SPName}");
            _cts = new CancellationTokenSource();
            
         
            _connectorStatus.Clear();
            _exchangeStatus.Clear();
            _spName = (string)SPName;
            _configs = await PortfolioHttpClient.GetOpeningLiquidationSubscriptionsForSp(_spName);
            Console.WriteLine($"*****************************   The number of instances got back from the database is {_configs.Count}");

            int id = 1;
           
            _configTableForLive = _configs.ToDictionary(c => c.StrategySPSubscriptionConfigId, c => c);
            var venues = await PortfolioHttpClient.GetVenues();
            foreach (var venue in venues)
            {
                var parts = venue.VenueName.Split("_");
                var c = new ConnectorStatus()
                {
                    Name = parts[0],
                    Status = ConnectorDown
                };
                _connectorStatus.Add(c);
                _exchangeStatus.Add(parts[0], c);
            }
            _venues = venues.ToDictionary(v => v.VenueId, v => v);
            _configs.ForEach(x =>
            {
                if (x.StrategyState) x.StrategyStateStr = "ON";
                else x.StrategyStateStr = "OFF";
                _instanceToIdTable.Add(x.StrategySPSubscriptionConfig.ConfigName, x.StrategySPSubscriptionConfigId);
                if (!_openingExchangeBalances.ContainsKey(x.StrategySPSubscriptionConfigId))
                {
                    _openingExchangeBalances.Add(x.StrategySPSubscriptionConfigId, new Dictionary<string, OpeningExchangeBalanceDTO>());
                    Console.WriteLine($"Adding entry into _openingExchangeBalances table with StrategySPSubscriptionConfigId {x.StrategySPSubscriptionConfigId}");
                }
                foreach (var exchange in x.StrategySPSubscriptionConfig.ExchangeDetails)
                {
                    var venueOpeningBalances = _openingExchangeBalances[x.StrategySPSubscriptionConfigId];
                    var venue = exchange.Venue.VenueName.Split("_")[0];
                    if (!venueOpeningBalances.ContainsKey(venue))
                    {
                        venueOpeningBalances.Add(venue, exchange.OpeningExchangeBalance);
                    }
                    x.CoinAmount += exchange.OpeningExchangeBalance.AmountToBeLiquidated;
                }
            });

            await HubConnection.StopAsync();
            HubConnection.On<MessageQueueData>("RealTimeUpdate", async (data) =>
            {
                await HandleMessages(data);
            });

           
            var connectorStatusMsgs = await PortfolioHttpClient.GetAllConnectorStatuses();
           
            foreach (var connector in connectorStatusMsgs)
            {
                await HandleConnectorStatusMsg(connector.Public.Venue, connector);
                await HandlePrivateConnectorStatus(connector.Private.Venue, connector);
            }
            Console.WriteLine("*************Here 2 ***************************");
            _venues = venues.ToDictionary(v => v.VenueId, v => v);

            //Console.WriteLine($"Just about to  get open orders etc - {_configs.Count}");
            foreach (var config in _configs)
            {
                config.LiquidatedCoin = config.CoinPair.Name.Split("/")[0];
                if (!_exchangeBalancesTable.ContainsKey(config.StrategySPSubscriptionConfigId))
                {
                    _exchangeBalancesTable.Add(config.StrategySPSubscriptionConfigId, new Dictionary<string, DifferentBalances>());
                }

                if (config.StrategyState)
                {
                    await StrategyInstanceOnProcessing(config);
                }
            }

            Console.WriteLine($"***************** Setting up the _masterExchangeBalancesList xxxxxx ");
            foreach (var instance in _exchangeBalancesTable.Keys)
            {
                Console.WriteLine($"***************** Setting up the _masterExchangeBalancesList yyyyyyyy ");
                if (_exchangeBalancesTable.ContainsKey(instance))
                {
                    var bals = _exchangeBalancesTable[instance];
                    var balList = bals.Values.ToList();
                    if (!_masterExchangeBalancesList.ContainsKey(instance))
                    {
                        Console.WriteLine($"***************** Setting up the _masterExchangeBalancesList zzzzzzzzz ");
                        _masterExchangeBalancesList.Add(instance, balList);
                    }
                }
            }

            StateHasChanged();
           // _chartTimer = new PeriodicTimer(TimeSpan.FromSeconds(5));
           // await ChartTimerExpired();
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error in OnInitializedAsync {e.StackTrace}");
        }
    }

    private async Task StrategyInstanceOnProcessing(LiquidationConfigurationDTO config)
    {
        var realTimeUpdateDto = new RealTimeStartDTO()
                {
                    SpName = SPName,
                    Instance = config.StrategySPSubscriptionConfig.ConfigName,
                    ConfigId = config.StrategySPSubscriptionConfigId
                };
                    //Console.WriteLine($"Bla Bla Bla 3");
        await PortfolioHttpClient.StartRealTimeUpdater(realTimeUpdateDto);

    // Console.WriteLine($"Just about to do exchange stuff count {config.StrategySPSubscriptionConfig.ExchangeDetails.Count}");
        foreach (var exchange in config.StrategySPSubscriptionConfig.ExchangeDetails)
        {
            // Need to request the orderbooks
            await PortfolioHttpClient.GetOrderBooks(exchange.Venue.VenueName, exchange.CoinPairs, SPName, config.StrategySPSubscriptionConfig.ConfigName);
            await PortfolioHttpClient.GetLastTrades(exchange.Venue.VenueName, exchange.CoinPairs, SPName, config.StrategySPSubscriptionConfig.ConfigName);
           // Console.WriteLine($"Just about to do exchange stuff - {exchange.Name}");
            //Console.WriteLine($"Calling GetPUblicStatus with venue = {exchange.Venue.VenueName}");
            await PortfolioHttpClient.GetPublicStatus(exchange.Venue);
            OpenOrdersRequest openOrdersRequest = new OpenOrdersRequest();
            openOrdersRequest.Venue = exchange.Venue.VenueName;
            openOrdersRequest.InstanceName = config.StrategySPSubscriptionConfig.ConfigName;
            openOrdersRequest.PortfolioName = SPName;
            openOrdersRequest.CoinPairs = exchange.CoinPairs;
            var coinPairs = exchange.CoinPairs.Split(",");
            var coinDict = new Dictionary<string, LivePriceGrid>();
            foreach (var pair in coinPairs)
            {
                var venue = exchange.Venue.VenueName.Split("_");
                var entry = new LivePriceGrid()
                {
                    Venue = venue[0],
                    CoinPair = pair,
                    Price = 0
                };
                coinDict.Add(pair, entry);
                
                Console.WriteLine($"**************************Adding entry to _livePriceGrid {entry.CoinPair} {entry.Venue} {entry.Price}");
                _livePriceGrid.Add(entry);
                
            }
            Console.WriteLine($"Sending request for Open Orders {openOrdersRequest.Venue}");
            await PortfolioHttpClient.GetOpenOrders(openOrdersRequest);
            GetBalanceRequest getBalanceRequest = new GetBalanceRequest();
            getBalanceRequest.Venue = exchange.Venue.VenueName;
            getBalanceRequest.InstanceName = config.StrategySPSubscriptionConfig.ConfigName;
            getBalanceRequest.PortfolioName = SPName;
            Console.WriteLine($"Sending request for Balances {openOrdersRequest.Venue}");
            await PortfolioHttpClient.GetBalancesFromVenue(getBalanceRequest);
            Console.WriteLine($"Sending request for Fills {openOrdersRequest.Venue}");

            
        }
        var fills = await PortfolioHttpClient.GetFills(config.StrategySPSubscriptionConfig.ConfigName);
        await HandleFills(fills, config.StrategySPSubscriptionConfig.ConfigName);
        var latestTrades = await PortfolioHttpClient.GetLatestTrades(config.StrategySPSubscriptionConfig.ConfigName);
        await HandleLatestTrades(latestTrades);
    }


    private async Task ChartTimerExpired()
    {
        try
        {
            while (await _chartTimer.WaitForNextTickAsync(_cts.Token))
            {
             //   Console.WriteLine($"In ChartTimerExpired");
             //   Console.WriteLine($"***************************Adding price {_lastBinanceFairValue}");

               // _lastBitfinexFairValue = _lastBinanceFairValue + 1.2m;
              //  var newData = new FairValueChartData(_lastBinanceFairValue, _lastBitfinexFairValue);
                
             //   if (_FairValueChartData.Count > dataLength)
             //       _FairValueChartData.RemoveAt(0);
             //   _FairValueChartData.Add(newData);
                
               // StateHasChanged();
            }
        }
        catch (Exception e)
        {
    //Handle the exception but don't propagate it
            Console.WriteLine($"Error in Strategy periodic timer {e.Message}");
        }
    }
    public void LoadStrategyInstance(int StrategyConfigId)
    {
        NavigationManager.NavigateTo($"strategyinstance/{StrategyConfigId}");
    }

    public void ToolbarClick(Syncfusion.Blazor.Navigations.ClickEventArgs args)
    {
        Console.WriteLine("In toolbarclick");
    }

    public void OnRecordDoubleClick(Syncfusion.Blazor.Grids.RecordDoubleClickEventArgs<LiquidationConfigurationDTO> args)
    {
        // NavigationManager.NavigateTo($"portfolio-instance-list/{args.RowData.}");
        var rowData = args.RowData;
        NavigationManager.NavigateTo($"strategy-instance-configure/{args.RowData.StrategySPSubscriptionConfig.ConfigName}");
        Console.WriteLine("In doubleclick");
    }

    public async Task OnActionBegin(ActionEventArgs<LiquidationConfigurationDTO> args)
    {
        if (args == null)
        {
            Console.WriteLine("OnActionBegin args is null");
            return;
        }
        if (args.Data == null)
        {
            Console.WriteLine("OnActionBegin args.Data is null");
            return;
        }

        if (args.RequestType.Equals((Syncfusion.Blazor.Grids.Action.Save)))
        {
            if (args.Action == "Edit")
            {
                Console.WriteLine("Got an edit");
                await PortfolioHttpClient.UpdateOpeningLiquidationSubscription(args.Data);
            }

        }
        else if (args.RequestType.Equals(Syncfusion.Blazor.Grids.Action.Delete))
        {
            Console.WriteLine("Deleting a record");
            if (args.Action == "Delete")
            {
                await PortfolioHttpClient.DeleteOpeningLiquidationSubscription(args.Data.Id);
            }
        }

        _configs = await PortfolioHttpClient.GetOpeningLiquidationSubscriptionsForSp(_spName);
        _configTableForLive = _configs.ToDictionary(c => c.StrategySPSubscriptionConfigId, c => c);
        await Grid?.Refresh();
    }

    public void OnAddNewInstance(MouseEventArgs args)
    {
        NavigationManager.NavigateTo($"create-strategy-instance");
    }

    public async Task GoToDashBoard( LiquidationConfigurationDTO? instance)
    {
        try
        {
            await HubConnection.StopAsync();
            NavigationManager.NavigateTo($"dashboard2/{instance.StrategySPSubscriptionConfigId}");
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error in GoToDashboard error Message is {e.Message} and StackTrace {e.StackTrace}");
        }
    }

    public async Task EditConfig(LiquidationConfigurationDTO config)
    {
        NavigationManager.NavigateTo($"EditLiquidationConfig/{config.StrategySPSubscriptionConfigId}");
    }

    public async Task SwitchMakerTakerMode(LiquidationConfigurationDTO? instance)
    {
        if (instance?.MakerMode == StratgeyMode.MAKER)
        {
            instance.MakerMode = StratgeyMode.TAKER;
        }
        else if (instance?.MakerMode == StratgeyMode.TAKER)
        {
            instance.MakerMode = StratgeyMode.MAKER;
        }
        await PortfolioHttpClient.UpdateOpeningLiquidationSubscription(instance);
  //      _configs = await PortfolioHttpClient.GetOpeningLiquidationSubscriptionsForSp(_spName);
      //  _configTableForLive = _configs.ToDictionary(c => c.StrategySPSubscriptionConfigId, c => c);
        foreach (var exchange in instance.StrategySPSubscriptionConfig.ExchangeDetails)
        {
            GetBalanceRequest getBalanceRequest = new GetBalanceRequest();
            getBalanceRequest.Venue = exchange.Venue.VenueName;
            getBalanceRequest.InstanceName = instance.StrategySPSubscriptionConfig.ConfigName;
            getBalanceRequest.PortfolioName = SPName;
            await PortfolioHttpClient.GetBalancesFromVenue(getBalanceRequest);

            var fills = await PortfolioHttpClient.GetFills(instance.StrategySPSubscriptionConfig.ConfigName);
            await HandleFills(fills, instance.StrategySPSubscriptionConfig.ConfigName);
        }
        await Grid?.Refresh();
    }

    public void PlaceMarketOrder(LiquidationConfigurationDTO? instance)
    {
        Console.WriteLine($"Selected the Config Instance for {instance.Id} and config name {instance.StrategySPSubscriptionConfig.ConfigName}");
        NavigationManager.NavigateTo($"market-order/{instance.StrategySPSubscriptionConfigId}");
    }

    private async Task HandleMessages(MessageQueueData msg)
    {
        Console.WriteLine($"StrategyInstanceForSP - In HandleMessages with msg type {msg.MessageType.ToString()}");
        switch (msg.MessageType)
        {
            case QueueMsgTypes.FAIRVALUEUPDATE:
                var fairValueData = JsonSerializer.Deserialize<FairValueData>(msg.Data);
                await HandleFairValueUpdate(fairValueData);
                break;
            case QueueMsgTypes.BALANCEUPDATE:
            case QueueMsgTypes.OPENINGBALANCE:
                var balanceUpdate = JsonSerializer.Deserialize<BalanceUpdate>(msg.Data);
                await HandleBalanceUpdate(msg.Venue, balanceUpdate);
                break;
            case QueueMsgTypes.START_OF_DAY:
                UpdateBalances();
                UpdateFills();
                break;

            case QueueMsgTypes.NEWORDER:
                var orderData = JsonSerializer.Deserialize<OwnOrderChange>(msg.Data);
  //              await HandleOwnOrderChanges(msg.Venue, orderData);
                break;
            case QueueMsgTypes.CANCELLEDORDER:
                var cancelledData = JsonSerializer.Deserialize<OwnOrderChange>(msg.Data);
  //              await HandleCancelledOrder(msg.Venue, cancelledData);
                break;
            case QueueMsgTypes.PARTIALLYFILLEDORDER:
                var partiallyFilledData = JsonSerializer.Deserialize<OwnOrderChange>(msg.Data);
    //            await HandlePartiallyFilledOrder(msg.Venue, partiallyFilledData);
                break;
            case QueueMsgTypes.FILLEDORDER:
                var filledData = JsonSerializer.Deserialize<OwnOrderChange>(msg.Data);
    //            await HandleFilledOrder(msg.Venue, filledData);
                break;
            case QueueMsgTypes.TRADE:
                var trade = JsonSerializer.Deserialize<TradeMsg>(msg.Data);
                await HandleTrade(msg.Venue, trade);
                break;
            case QueueMsgTypes.OPEN_ORDERS_RESPONSE:
                var openOrders = JsonSerializer.Deserialize<List<OwnOrderChange>>(msg.Data);
 //               await HandleOpenOrders(msg.Venue, openOrders);
                break;
            case QueueMsgTypes.STRATEGY_ALIVE_PING:
                var strategyAliveData = JsonSerializer.Deserialize<StrategyInstanceConnectionStatus>(msg.Data);
                HandleStrategyAlive(strategyAliveData);
                break;
            case QueueMsgTypes.STRATEGY_CONTROL_MSG:
                var strategyControlData = JsonSerializer.Deserialize<StrategyControlResponse>(msg.Data);
                HandleStrategyControlMsg(strategyControlData);
                break;
            case QueueMsgTypes.CONNECTOR_STATUS:
                var connectorStatus = JsonSerializer.Deserialize<ConnectorStatusMsg>(msg.Data);
                if (connectorStatus != null)
                {
                    if (msg.IsPublic)
                        await HandleConnectorStatusMsg(msg.Venue, connectorStatus);
                    else
                        await HandlePrivateConnectorStatus(msg.Venue, connectorStatus);
                }
                break;
            default:
                Logger.LogInformation("Unhandled Message - {MessageType}", msg.MessageType.ToString());
                break;
        }
    }

    private async Task HandleFairValueUpdate(FairValueData? fairValueData)
    {
        if (fairValueData != null)
        {

            Dictionary<string, LivePriceGrid> entry = null;
            LivePriceGrid gridEntry = null;
            var venue = fairValueData.Venue.Split("_")[0];
            if (_livePriceTable.ContainsKey((fairValueData.Venue)))
            {
                entry = _livePriceTable[fairValueData.Venue];
            }
            else
            {
                entry = new Dictionary<string, LivePriceGrid>();
                _livePriceTable.Add(fairValueData.Venue, entry);
            }

            if (entry.ContainsKey(fairValueData.Symbol))
                gridEntry = entry[fairValueData.Symbol];
            else
            {
                gridEntry = new LivePriceGrid();
               
               // _livePriceGrid.Add(gridEntry);
                entry.Add(fairValueData.Symbol, gridEntry);
               
                _livePriceIndexCounter++;
                gridEntry.Id = _livePriceIndexCounter;
             //   Console.WriteLine($"*****************************************Adding gridEntry with Id={gridEntry.Id}");
                gridEntry.CoinPair = fairValueData.Symbol;
                gridEntry.Venue = venue;

            }

            var prevPrice = gridEntry.Price;
            gridEntry.Price = Math.Round(fairValueData.Price, 2, MidpointRounding.ToEven);
            if (gridEntry.Price > prevPrice)

                gridEntry.Color = "green";
            else if (gridEntry.Price < prevPrice)
                gridEntry.Color = "red";
            else
                gridEntry.Color = "black";

            _livePriceGrid.Clear();
            foreach (var x in _livePriceTable.Values)
            {
                _livePriceGrid.AddRange(x.Values.ToList());
            }
            _livePriceGrid = _livePriceGrid.OrderByDescending(x => x.Price).ToList();
          //  await _GridLivePrice.SetRowDataAsync(gridEntry.Id, _livePriceGrid[gridEntry.Id-1]);
         //   HandlePreviousPrice(fairValueData);
            StateHasChanged();
        }
    }

    private async Task HandleBalanceUpdate(string v, BalanceUpdate balance)
    {
        try
        {
            var venue = v.Split("_")[0];
            var instance = balance.Balance.Instance;
            var id = _instanceToIdTable[balance.Balance.Instance];
            var data = _configTableForLive[id];
            var differingBalances = CreateOrGetBalance(id, data, venue);
           
            differingBalances.Instance = balance.Balance.Instance;
            differingBalances.Account = balance.Balance.Account;
            differingBalances.Venue = venue;
            
       //     Console.WriteLine($"In HandleBalanceUpdate chosen instance = {_chosenInstance} ");
            if (_instanceToIdTable.ContainsKey(balance.Balance.Instance))
            {
                if (balance.Currency.Equals(data.CurrencyLiquidatedFrom))
                {
                    
                    differingBalances.FromCoinName = balance.Currency;
               //     Console.WriteLine($"Handling BTC - {balance.Balance.Available}");
                   // differingBalances.DayLiquidationFrom = Math.Round(balance.Balance.Available, data.AmountDecimals, MidpointRounding.ToEven);
                    differingBalances.TotalLiqudationFrom = Math.Round(differingBalances.OpeningBalanceForLiquidatedCoin -  balance.Balance.Available, 
                                                                        data.AmountDecimals, MidpointRounding.ToEven);
                    differingBalances.CurrentAvailableCoinBalance = balance.Balance.Available;
                    differingBalances.DayLiquidationFrom = Math.Round(differingBalances.StartOfDayBalanceForLiquidationCoin - balance.Balance.Available, 
                                                                        data.AmountDecimals, MidpointRounding.ToEven); 
                    //differingBalances.OpeningBalanceForLiquidatedCoin
                    var totals = SumTotalBalances(id);
                    data.BalanceLiquidationFrom = Math.Round(totals.Item4, data.PriceDecimals, MidpointRounding.ToEven);
                    data.DailyLiquidationFrom = Math.Round(totals.Item3, data.PriceDecimals, MidpointRounding.ToEven);
                    Console.WriteLine($"Here 4");
                    Console.WriteLine($"1. Attempting to update grid for id={id} {differingBalances.Venue} from={data.BalanceLiquidationFrom} ");
                   
                }
                else if (balance.Currency.Equals(data.CurrencyLiquidatedTo))
                {
                   
                    differingBalances.ToStableCoinName = balance.Currency;
               //     Console.WriteLine($"Handling USDT - {balance.Balance.Available}");
                    differingBalances.DayLiquidationTo = Math.Round(balance.Balance.Available, data.PriceDecimals, MidpointRounding.ToEven);
                    differingBalances.TotalLiqudationTo = Math.Round(balance.Balance.Available, data.AmountDecimals, MidpointRounding.ToEven);
                    differingBalances.CurrentAvailableStableBalance = balance.Balance.Available;
                    var totals = SumTotalBalances(id);
                    data.BalanceLiquidationTo = Math.Round(totals.Item2, data.PriceDecimals, MidpointRounding.ToEven);
                    data.DailyLiquidationTo = Math.Round(totals.Item1, data.AmountDecimals, MidpointRounding.ToEven);
                   
                    
                }
                if (!string.IsNullOrEmpty(_chosenInstance))
                {
                    if (balance.Balance.Instance.Equals(_chosenInstance))
                    {
                        if (_masterExchangeBalancesList.ContainsKey(id))
                        {
                            _chosenBalanceList = _masterExchangeBalancesList[id];
                            if (!_chosenBalanceList.Any())
                            {
                                if (_exchangeBalancesTable.ContainsKey(id))
                                {
                                    var bals = _exchangeBalancesTable[id];
                                    var balList = bals.Values.ToList();
                                    _masterExchangeBalancesList[id] = balList;
                                    _chosenBalanceList = _masterExchangeBalancesList[id];
                                }
                            }
                        }
                        else
                        {
                            Console.WriteLine($"No entry in _masterExchangeBalancesList for {id}");
                        }
                    }
                }
                StateHasChanged();
            }
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error in HandleBalanceUpdate - {e.Message}");
        }
    }

    private DifferentBalances CreateOrGetBalance(int id, LiquidationConfigurationDTO data, string venue)
    {
        Console.WriteLine($"In CreateOrGetBalance - venue is {venue}");
        Dictionary<string, DifferentBalances> venueBalances = null;
        DifferentBalances differingBalances = null;
        if (_exchangeBalancesTable.ContainsKey(id))
        {
            venueBalances = _exchangeBalancesTable[id];
            if (venueBalances.ContainsKey(venue))
            {
                Console.WriteLine($"Got the venueBalances");
                differingBalances = venueBalances[venue];
            }
            else
            {
                var openingBalances = GetOpeningBalance(id, venue);

                if (openingBalances != null)
                {
                    differingBalances = new DifferentBalances()
                    {
                        Id = venueBalances.Count,
                        OpeningBalanceForLiquidatedCoin = openingBalances.LiquidatingFromOpeningBalance,
                        OpeningBalanceForLiquidatedToCurrency = openingBalances.LiquidatingToOpeningBalance
                    };

                    venueBalances[venue] = differingBalances;
                    differingBalances.Id = venueBalances.Count;
                }
                else
                {
                    Console.WriteLine($"Got no opening balance");
                }
            }
        }
        else
        {
            var openingBalances = GetOpeningBalance(id, venue);
            differingBalances = new DifferentBalances()
            {
                Id = venueBalances.Count,
                OpeningBalanceForLiquidatedCoin = openingBalances.LiquidatingFromOpeningBalance,
                OpeningBalanceForLiquidatedToCurrency = openingBalances.LiquidatingToOpeningBalance
            };
            venueBalances = new Dictionary<string, DifferentBalances>();
            venueBalances[venue] = differingBalances;
            
            _exchangeBalancesTable.Add(id, venueBalances);

        }
        return differingBalances;
    }

    private OpeningExchangeBalanceDTO GetOpeningBalance(int id, string venue)
    {
        Console.WriteLine($"In GetOpeningBalance - with id = {id}");
        if (_openingExchangeBalances.ContainsKey(id))
        {
            Console.WriteLine($"Ummmmmhhh got a balance though");
            var venueOpeningBalancesForInstance = _openingExchangeBalances[id];
            if (venueOpeningBalancesForInstance.ContainsKey(venue))
            {
                var openingBalances = venueOpeningBalancesForInstance[venue];
                return openingBalances;
            }
            else
            {
                Console.WriteLine($"Ah now I know");
            }
        }
        return null;
    }

    private Tuple<decimal, decimal, decimal, decimal> SumTotalBalances(int id)
    {
        if (_exchangeBalancesTable.ContainsKey(id))
        {
            var venueBalances = _exchangeBalancesTable[id];
            decimal dayToTotal = 0;
            decimal toTotal = 0;
            decimal dayFromTotal = 0;
            decimal fromTotal = 0;
            var venueBalanceList = venueBalances.Values.ToList();
            venueBalanceList.ForEach(v =>
            {
                dayToTotal += v.DayLiquidationTo;
                toTotal += v.TotalLiqudationTo;
                dayFromTotal += v.DayLiquidationFrom;
                fromTotal += v.TotalLiqudationFrom;
            });

            return  Tuple.Create(dayToTotal, toTotal, dayFromTotal, fromTotal);
        }
        throw new Exception($"SumTotalBalances - no entry in exchange balance table for {id}");

    }

    private DifferentFills CreateOrGetFills(int id,  string venue)
    {

        Dictionary<string, DifferentFills> venueFills = null;
        DifferentFills differingFills = null;
   
        if (_exchangeFillsTable.ContainsKey(id))
        {
            venueFills = _exchangeFillsTable[id];
            if (venueFills.ContainsKey(venue))
            {
                differingFills = venueFills[venue];
            }
            else
            {
                differingFills = new DifferentFills();
                venueFills[venue] = differingFills;
                differingFills.Id = venueFills.Count;
            }
        }
        else
        {
            differingFills = new DifferentFills();
            venueFills = new Dictionary<string, DifferentFills>();
            venueFills[venue] = differingFills;
            differingFills.Id = venueFills.Count;
            _exchangeFillsTable.Add(id, venueFills);
      
        }
        return differingFills;
    }

    private Tuple<int, int> SumTotalFills(int id)
    {
        if (_exchangeFillsTable.ContainsKey(id))
        {
            var venueFills = _exchangeFillsTable[id];
            int dayTotal = 0;
            int Total = 0;
           
            var venueFillsList = venueFills.Values.ToList();
            venueFillsList.ForEach(v =>
            {
                dayTotal += v.DayTotal;
                Total += v.Total;
            });

            return  Tuple.Create(dayTotal, Total);
        }
        throw new Exception($"SumTotalFills - no entry in exchange fills table for {id}");
    }

    public void CustomizeLivePriceCell(QueryCellInfoEventArgs<LiquidationConfigurationDTO> args)
    {
        if (args.Column.Field == "BalanceLiquidationFrom" || args.Column.Field == "BalanceLiquidationTo" || args.Column.Field == "DailyLiquidationFrom" || args.Column.Field == "DailyLiquidationTo"
                                || args.Column.Field ==  "CoinAmount" || args.Column.Field ==  "DailyLiquidationTarget" || args.Column.Field ==  "TotalFills" || args.Column.Field ==  "DailyFills")
        {
            //args.Cell.AddClass(new string[] { "same" });
            args.Cell.AddStyle(new string[] { "background-color:" + "white" + ";" }); 
        }
        else if (args.Column.Field == "StrategyStateStr")
        {
            Console.WriteLine($"In CustomizeLivePriceCell with a change in strategy state");
            if (args.Data.StrategyState)
                args.Cell.AddStyle(new string[] { "background-color:" + "green" + ";" }); 
            
               // args.Cell.AddClass((new string[] {"london"}));
            else
                args.Cell.AddStyle(new string[] { "background-color:" + "red" + ";" });
                //args.Cell.AddClass((new string[] {"redmond"}));
        }
      
    }

    public void CustomizeConnectorStatus(QueryCellInfoEventArgs<ConnectorStatus> args)
    {
        Console.WriteLine($"In CustomizeConnectorStatus with a change in  state");
        if (args.Column.Field == "Status")
        {
            if (args.Data.Status == ConnectorDown)
            {
                Console.WriteLine($"In CustomizeConnectorStatus should be red");
                
                //args.Cell.AddClass(new string[] { "redmond" });
                args.Cell.AddStyle(new string[] { "background-color:" + "red" + ";" }); 
            }
            else if (args.Data.Status == ConnectorUp)
            {
                Console.WriteLine($"In CustomizeConnectorStatus should be green");
                args.Cell.AddStyle(new string[] { "background-color:" + "green" + ";" }); 
            }
        }

    }

    public void CustomizeCell(QueryCellInfoEventArgs<LivePriceGrid> args)
    {
        Console.WriteLine("In CustomizeCell");
        if (args.Column.Field == "Price")
        {
            if (_previousLivePriceTable.ContainsKey(args.Data.Venue))
            {
                var entry = _previousLivePriceTable[args.Data.Venue];
                if (entry.ContainsKey(args.Data.CoinPair))
                {
                    var data = entry[args.Data.CoinPair];
                    if (args.Data.Price < data.Price)
                    {
                        args.Cell.AddClass(new string[] { "redmond" });
                        args.Cell.AddStyle(new string[] { "background-color:" + "red" + ";" }); 
                    }
                    else if (args.Data.Price > data.Price)
                    {
                        args.Cell.AddClass(new string[] { "london" });
                        args.Cell.AddStyle(new string[] { "background-color:" + "green" + ";" }); 
                    }
                    else
                    {
                        args.Cell.AddClass(new string[] { "same" });
                        args.Cell.AddStyle(new string[] { "background-color:" + "lightorange" + ";" });
                    }
                }
                else
                {
                   // args.Cell.AddClass(new string[] { "london" });
                    args.Cell.AddStyle(new string[] { "background-color:" + "green" + ";" });
                }
            }
            else
            {
                ///args.Cell.AddClass(new string[] { "london" });
                args.Cell.AddStyle(new string[] { "background-color:" + "green" + ";" });
            }
        }
    }

    private void UpdateBalances()
    {
        foreach (var venueBalances in _masterExchangeBalancesList.Values)
        {
            foreach (var bal in venueBalances)
            {
                bal.StartOfDayBalanceForLiquidationCoin = bal.CurrentAvailableCoinBalance;
                bal.DayLiquidationTo = bal.CurrentAvailableStableBalance;
            }
        }
    }

    private void UpdateFills()
    {

    }

    private async Task HandleFills(List<FillsInfoForInstance> fills, string instance)
    {
        var id = _instanceToIdTable[instance];
        var data = _configTableForLive[id];
        foreach (var venueFill in fills)
        {
            if (_venues.ContainsKey(venueFill.VenueId))
            {
                var venue = _venues[venueFill.VenueId].VenueName.Split("_")[0];

                var fillsInstance = CreateOrGetFills(id, venue);
                if (fillsInstance != null)
                {
                    fillsInstance.Instance = instance;
                    fillsInstance.Account = venueFill.Account;
                    fillsInstance.Venue = venue;
                    fillsInstance.DayTotal = venueFill.DailyFills;
                    fillsInstance.Total = venueFill.TotalFills;
                }
                Console.WriteLine($"********************* venue fill details total fills {venueFill.TotalFills} total liquidated {venueFill.TotalLiquidated}");
               
                
                var balanceInstance = CreateOrGetBalance(id, data, venue);
                if (balanceInstance != null)
                {
                    balanceInstance.Venue = venue;
                    balanceInstance.Instance = instance;
                    balanceInstance.Account = venueFill.Account;
                    balanceInstance.TotalLiqudationFrom = Math.Round(venueFill.TotalLiquidated, data.AmountDecimals, MidpointRounding.ToEven);
                    balanceInstance.DayLiquidationFrom = Math.Round(venueFill.LiquidatedToday, data.AmountDecimals, MidpointRounding.ToEven);
                    balanceInstance.TotalLiqudationTo = Math.Round(venueFill.TotalStableEarned, 2, MidpointRounding.ToEven);
                    balanceInstance.DayLiquidationTo = Math.Round(venueFill.TotalStableEarnedToday, 2, MidpointRounding.ToEven);

                    data.TotalCoinLiquidated += venueFill.TotalLiquidated;
                    data.TotalCoinLiquidatedToday += venueFill.LiquidatedToday;

                    data.TotalCoinLiquidated = Math.Round(data.TotalCoinLiquidated, data.AmountDecimals, MidpointRounding.ToEven);
                    data.TotalCoinLiquidatedToday = Math.Round(data.TotalCoinLiquidatedToday, data.AmountDecimals, MidpointRounding.ToEven);

                    Console.WriteLine($"HandleFills Adding fills instance for {venue} with total fills = {fillsInstance.Total} ");
                }
                else
                {
                    Console.WriteLine($" Oh ffs the balance instance is null");
                }
            }
        }
      //  var parts = venue.Split("_");
        
     
       // var totals = SumTotalFills(id);
        data.DailyFills = fills.Sum(f => f.DailyFills);
        data.TotalFills = fills.Sum(f => f.TotalFills);
        StateHasChanged();
        //await Grid.SetRowDataAsync(id, data);
    }

    private void FormatDecimals(List<OwnOrderChange> ownOrderChanges)
    {
        ownOrderChanges.ForEach(o =>
        {
            o.Price =  Math.Round(o.Price, 3, MidpointRounding.ToEven);
            o.Quantity = Math.Round(o.Quantity, 3, MidpointRounding.ToEven);
            o.FilledQuantity = Math.Round(o.FilledQuantity, 5, MidpointRounding.ToEven);
            o.RemainingQuantity = Math.Round(o.RemainingQuantity, 5, MidpointRounding.ToEven);
            switch(o.Status)
            {
                case "OPEN":
                    o.Status = "Open";
                    break;
                case "ORDER_PARTIALLY_FILLED":
                    o.Status = "Partially Filled";
                    break;
                case "PENDING":
                    o.Status = "Pending";
                    break;
            }
        });
    }

    private void FormatDecimals(List<TradeMsg> trades)
    {
        trades.ForEach(o =>
        {
            o.Price =  Math.Round(o.Price, 3, MidpointRounding.ToEven);
            o.Quantity = Math.Round(o.Quantity, 3, MidpointRounding.ToEven);
            o.FilledQuantity = Math.Round(o.FilledQuantity, 5, MidpointRounding.ToEven);
            o.RemainingQuantity = Math.Round(o.RemainingQuantity, 5, MidpointRounding.ToEven);
            switch(o.Status)
            {
                case "OPEN":
                    o.Status = "Open";
                    break;
                case "ORDER_PARTIALLY_FILLED":
                    o.Status = "Partially Filled";
                    break;
                case "PENDING":
                    o.Status = "Pending";
                    break;
            }
        });
    }

    private void HandleStrategyAlive(StrategyInstanceConnectionStatus status)
    {
        if (status.Status)
        {
            if (!_strategyColorStatus.ContainsKey(status.InstanceName))
                _strategyColorStatus[status.InstanceName] = StrategyUp;
            else if (_strategyColorStatus[status.InstanceName] == StrategyDown)
            {
                
                _strategyColorStatus[status.InstanceName] = StrategyUp;
                StateHasChanged();
              
            }
        }
        else
        {
            if (!_strategyColorStatus.ContainsKey(status.InstanceName))
                _strategyColorStatus[status.InstanceName] = StrategyDown;
            else if (_strategyColorStatus[status.InstanceName] == StrategyUp)
            {
                _strategyColorStatus[status.InstanceName] = StrategyDown;
                StateHasChanged();
            }
        }
    }

    private void HandleStrategyControlMsg(StrategyControlResponse strategyControlData)
    {
        Console.WriteLine("**************** In HandleStrategyControlMsg ***************************");
        if (strategyControlData.State == StrategyProcessStatus.STARTED)
        {
            if (_strategyStatus == StrategyDown)
            {
                _strategyStatus = StrategyUp;
                StateHasChanged();
            }
        }
        else if (strategyControlData.State == StrategyProcessStatus.STOPPED ||
                 strategyControlData.State == StrategyProcessStatus.EXITED || 
                 strategyControlData.State == StrategyProcessStatus.UNEXPECTED_STOP)
        {
            if (_strategyStatus == StrategyUp)
            {
                _strategyStatus = StrategyDown;
                StateHasChanged();
            }
        }
    }

    private async Task HandleConnectorStatusMsg(string venue, ConnectorStatusMsg statusMsg)
    {
        var parts = venue.Split("_");
        ConnectorStatus connector = null;
        if (!statusMsg.Public.IsConnected) 
        {
            if (_exchangeStatus.ContainsKey(parts[0]))
            {
                Console.WriteLine($"Connector status for {parts[0]} is down");
                connector = _exchangeStatus[parts[0]];
                connector.Status = ConnectorDown;
                connector.Color = "red";
            }
        }
        else
        {
            if (_exchangeStatus.ContainsKey(parts[0]))
            {
                Console.WriteLine($"Connector status for {parts[0]} is up");
                connector = _exchangeStatus[parts[0]];
                connector.Status = ConnectorUp;
                connector.Color = "green";
            }
        }
        _connectorStatus = _exchangeStatus.Values.ToList();
    //  await ConnectorStatusGrid?.SetRowDataAsync(connector.Name, connector);
        StateHasChanged();
    }

    private async Task HandlePrivateConnectorStatus(string venue, ConnectorStatusMsg statusMsg)
    {
        if (statusMsg.Instance == null) return;
        // Get the instance
        if (_instanceToIdTable.ContainsKey(statusMsg.Instance))
        {
            Console.WriteLine($"In HandlePrivateConnectorStatus *******");
            var id = _instanceToIdTable[statusMsg.Instance];
            if (!statusMsg.Private.IsConnected)
            {
                if (!_badRowList.Contains(id))
                {
                    _badRowList.Add(id);
                }
            }
            else
            {
                if (!_goodRowList.Contains(id))
                {
                    _goodRowList.Add(id);
                }
            }
        }
    }

    public void RowBound(RowDataBoundEventArgs<LiquidationConfigurationDTO> args)
    {
        Console.WriteLine($"In RowBound with {args.Data.StrategySPSubscriptionConfig.ConfigName}");
        if (_badRowList.Contains(args.Data.StrategySPSubscriptionConfigId))
        {
            Console.WriteLine($"In RowBound with {args.Data.StrategySPSubscriptionConfig.ConfigName} 2");
            //args.Row.AddClass(new string[] { "rowcolor" });
        }
    }

    private async Task HandleOpenOrders(string venue, List<OwnOrderChange> openOrders)
    {
        try
        {
            var instance = "";
            if (openOrders.Any())
            {
                instance = openOrders[0].Instance;
            }
            else
            {
                Console.WriteLine($"HandleOpenOrders - no open orders from {venue}");
                return;
            }

            Console.WriteLine($"*************************in HandleOpenOrders _chosenInstance = {_chosenInstance}");
            if (_masterOrderTable.ContainsKey(instance))
            {
                var orderTable = _masterOrderTable[instance];
                foreach (var order in openOrders)
                {
                    if (order.Instance.Equals(_chosenInstance))
                    {
                        orderTable[order.ClientOid] = order;
                        order.Venue = venue;
                        if (order.RemainingQuantity == 0)
                        {
                            orderTable.Remove(order.ClientOid);
                        }
                    }
                }
                if (_chosenInstance.Equals(instance))
                {
                    var l = orderTable.Values.ToList();
                    _openOrderList.Clear();
                    _openOrderList = l.OrderByDescending(o => o.OrderTime).ToList();
                    FormatDecimals(_openOrderList);
                    Console.WriteLine($"****************************   Open Order List Size = {_openOrderList.Count}");
                    StateHasChanged();
                }
            }
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error in HandleOpenOrders {e.Message}");
        }
    }

    private async Task HandleTrade(string venue, TradeMsg? trade, bool ignoreFills=false )
    {
        try
        {
            if (trade != null)
            {
                if (!trade.IsBuy)
                {
                    if (!ignoreFills)
                    {
                        var parts = venue.Split("_");

                        var id = _instanceToIdTable[trade.Instance];
                        Console.WriteLine($"The id being used is {id}");
                        var data = _configTableForLive[id];
                        var differingFills = CreateOrGetFills(id, venue);
                        differingFills.Instance = trade.Instance;
                        differingFills.Account = trade.Account;
                        differingFills.Venue = parts[0];
                        if (trade.Timestamp.Date == DateTime.UtcNow.Date)
                            differingFills.DayTotal++;
                        differingFills.Total++;
                        var totals = SumTotalFills(id);
                        data.DailyFills = totals.Item1;
                        data.TotalFills = totals.Item2;
                        //await Grid.SetRowDataAsync(id, data);
                        data.TotalCoinLiquidated += trade.Quantity;
                        data.TotalCoinLiquidatedToday += trade.Quantity;
                        data.TotalCoinLiquidated = Math.Round(data.TotalCoinLiquidated, data.AmountDecimals, MidpointRounding.ToEven);
                        data.TotalCoinLiquidatedToday = Math.Round(data.TotalCoinLiquidatedToday, data.AmountDecimals, MidpointRounding.ToEven);
                        if (trade.Instance.Equals(_chosenInstance))
                        {
                            if (_masterExchangeFillsList.ContainsKey(id))
                            {
                                _chosenFillsList = _masterExchangeFillsList[id];
    
                            }
                        }
                    }
                }
                Dictionary<string, TradeMsg> tradeTable = null;
                if (_masterTradeTable.ContainsKey(trade.Instance))
                    tradeTable = _masterTradeTable[trade.Instance];
                else
                {
                    tradeTable = new Dictionary<string, TradeMsg>();
                    _masterTradeTable[trade.Instance] = tradeTable;
                }
                Console.WriteLine($"In HandleTrade");
                trade.Venue = venue;
                if (!tradeTable.ContainsKey(trade.TradeId))
                {
                    tradeTable.Add(trade.TradeId, trade);
                    if (trade.Instance.Equals(_chosenInstance))
                    {
                        var l = tradeTable.Values.ToList();
                        _tradeList.Clear();
                        _tradeList = l.OrderByDescending(o => o.OrderTime).Take(15).ToList();
                        FormatDecimals(_tradeList);
                        StateHasChanged();
                    }
                }
                else
                {
                    Logger.LogInformation("Duplicate entry for {TradeId} ", trade.TradeId);
                }
            }
        }
        catch (Exception e)
        {
            Console.WriteLine($"Caught exception in HandleTrade {e.Message} - {e.StackTrace}");
        }
    }

    private async Task HandleLatestTrades(List<TradeDTO> latestTrades)
    {
        try
        {
            foreach (var trade in latestTrades)
            {
                if (trade == null)
                    Console.WriteLine("Problem is that the trade is null");
                var v = _venues[trade.VenueId].VenueName;
                var venue = v.Split("_");
                var tradeMsg = new TradeMsg()
                {
                    TradeId = trade.ExchangeTradeId,
                    OrderId = trade.OrderId,
                    Venue = venue[0],
                    Symbol = trade.CoinPair.Name,
                    Price = trade.Price,
                    Quantity = trade.Quantity,
                    FilledQuantity = trade.Quantity,
                    RemainingQuantity = trade.LeaveQuantity,
                    IsBuy = trade.IsBuy,
                    Timestamp = trade.DateCreated,
                    Instance =  trade.InstanceName,
                    Account = trade.SP.Name
                };
                await HandleTrade(tradeMsg.Venue, tradeMsg, true);
            }
        }
    
        catch (Exception e)
        {
            Console.WriteLine($"Caught exception in HandleLatestTrades {e.StackTrace}");
        }
    }

    private async Task HandleFilledOrder(string venue, OwnOrderChange? order)
    {
      
        if (order != null)
        {
            var orderTable = _masterOrderTable[order.Instance];
          
            if (orderTable.ContainsKey(order.ClientOid))
            {
                orderTable.Remove(order.ClientOid);
                if (order.Instance.Equals(_chosenInstance))
                {
                   
                    var l = orderTable.Values.ToList();
                    _openOrderList.Clear();
                    _openOrderList = l.OrderByDescending(o => o.OrderTime).ToList();
                    _openOrderList.Remove(order);
                    FormatDecimals(_openOrderList);
                    StateHasChanged();
                }
            }
            else
            {
                ; // Shouldn't happen
            }
            
        }
    }

    private async Task HandlePartiallyFilledOrder(string venue, OwnOrderChange? order)
    {
        if (order != null)
        {
            
            var orderTable = _masterOrderTable[order.Instance];
            
            order.Venue = venue;
            if (orderTable.ContainsKey(order.ClientOid))
            {
                orderTable[order.ClientOid] = order;
                if (order.RemainingQuantity == 0)
                    orderTable.Remove(order.ClientOid);
                if (order.Instance.Equals(_chosenInstance))
                {
                    var l = orderTable.Values.ToList();
                    _openOrderList.Clear();
                    _openOrderList = l.OrderByDescending(o => o.OrderTime).ToList();
                    FormatDecimals(_openOrderList);
                    StateHasChanged();
                }
            }
            else
            {
                ; // Shouldn't happen
            }
        }
    }

    private async Task HandleCancelledOrder(string venue, OwnOrderChange? order)
    {
        
        if (order != null)
        {
            var orderTable = _masterOrderTable[order.Instance];
          
            order.Venue = venue;
            if (orderTable.ContainsKey(order.ClientOid))
            {
                orderTable.Remove(order.ClientOid);
                if (order.Instance.Equals(_chosenInstance))
                {
                    var l = orderTable.Values.ToList();
                    _openOrderList.Remove(order);
                    _openOrderList.Clear();
                    _openOrderList = l.OrderByDescending(o => o.OrderTime).ToList();
                    FormatDecimals(_openOrderList);
            
                    StateHasChanged();
                }
            }
            else
            {
                ; // Shouldn't happen
            }
        }
    }

    private async Task HandleOwnOrderChanges(string venue, OwnOrderChange? order)
    {
        if (order != null)
        {
            Dictionary<string, OwnOrderChange> orderTable = null;
            if (_masterOrderTable.ContainsKey(order.Instance))
            {
                orderTable = _masterOrderTable[order.Instance];
                
            }
            else
            {
                orderTable = new Dictionary<string, OwnOrderChange>();
                _masterOrderTable.Add(order.Instance, orderTable);
            }
            
            order.Venue = venue;
            if (orderTable.ContainsKey(order.ClientOid))
            {
                Console.WriteLine($"In table already - In HandleOwnOrderChanges for {order.OrderId} for instance {order.Instance} and chosen instance = {_chosenInstance}");
            }
            else
            {
                
                orderTable[order.ClientOid] = order;
                if (order.Instance.Equals(_chosenInstance))
                {
                    
                    var l = orderTable.Values.ToList();
                    _openOrderList.Clear();
                    _openOrderList = l.Where(o => o.RemainingQuantity > 0).OrderByDescending(o => o.OrderTime).ToList();
                    FormatDecimals(_openOrderList);
                    StateHasChanged();
                }
                else
                    Console.WriteLine("In No Match - HandleOwnOrderChanges ");
            }
        }
    }

    private async Task StrategyOnOffEvent(LiquidationConfigurationDTO row)
    {
        StrategyProcessDetails strategyProcessDetails =  new StrategyProcessDetails()
        {
            AccountName = SPName,
            ConfigName = row.StrategySPSubscriptionConfig.ConfigName,           
            StrategyConfigId = row.StrategySPSubscriptionConfigId
        };

      //  Console.WriteLine("We got here anyways");
        if (row.StrategyState)
        {
            strategyProcessDetails.Enable = false;
            row.StrategyState = false;
        }
        else
        {
            strategyProcessDetails.Enable = true;
            row.StrategyState = true;
        }
        Console.WriteLine("Calling SendStrategyProcessCommand");
        await PortfolioHttpClient.SendStrategyProcessCommand(strategyProcessDetails);
        await StrategyInstanceOnProcessing(row);
    }

    public void OnTabSelected(SelectEventArgs args) 
    { 
        Console.WriteLine($"In OnTabSelected with args.Name {args.Name}");
    } 

    public void OnTabSelecting(SelectingEventArgs args) 
    { 
        Console.WriteLine($"In OnTabSelecting with args.Name {args.Name}");
    } 

 } 
<style>

    .headerRow {
        color: #927b00;
    }

    .e-dashboardlayout.e-control.e-responsive {
        background: black;
        opacity: 0.8;
    }

    .configHeaderRow {
        color: #927b00;
        font-family: cambria;
        font-weight: bolder;
        font-size: 1.2rem;
        background: black;
        opacity: 1.0;
    }

    .e-panel-content {
        text-align: center;
        color: white;
        font-family: cambria;
        font-weight: bold;
        background: black;
        opacity: 0.9;
    }

   .e-custom {
     
        height: 100%;
        width: 100%;
    }

   

    .e-custom, .e-custom:hover, .e-custom:focus, .e-custom:active {
        background-color: #927b00;
        color: white;
        font-size: 0.9rem; 
        font-weight: bold;
    }

     .e-gridheader .e-columnheader .e-headercell  {
       background-color: black;
        opacity: 0.9;
       color : #927b00;
       font-weight: bold;
        font-size: 40px;
    }
    .expense-container
    {
        color: white;
        font-size: 15px;
        margin-top: 0px;
        padding-left: 2px;
    }
   .e-grid .e-gridcontent .e-row .e-rowcell{
       color:#927b00;
       font-weight: bolder;
       background-color: black;
       opacity: 0.7;
       font-size: 20px; 
   }
  
</style>

